<html>
<head>
	<meta charset="UTF-8">
	<title>main</title>
	<style>
	.container{overflow:hidden;}
.seek-bar{margin:100px auto 50px;position:relative;width:calc(100% - 100px);height:10px;background:#222;border-radius:5px;}
.seek-bar>.circle{cursor:grab;position:absolute;left:0;top:50%;width:30px;height:30px;transform:translate(-50%,-50%);touch-action: none;}
.seek-bar>.circle>svg{pointer-events:none;width:0;height:0;}
.seek-bar>.circle>div{height:100%;-webkit-filter:url("#svg_goo");filter:url("#svg_goo");}
.seek-bar>.circle>div>em{pointer-events:none;position:absolute;display:block;width:30px;height:30px;left:50%;top:50%;transform:translate(-50%,-50%);background:#2196f3;border-radius:100%;transition:all .5s;}
.seek-bar>.circle>span{pointer-events:none;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);filter:none;color:#fff;font-size:18px;transition:all .5s;white-space:nowrap;text-align:center;}

.seek-bar>.circle.s_on>span{margin-top:-50px;font-size:20px;}
.seek-bar>.circle.s_on>div>em:nth-child(2){margin-top:-50px;background:#65bbff;width:40px;height:40px;}
	</style>
<head>
<body>
	<p>
		<img src="kpu.png"
		style="display:block; margin:150 auto; width:400px; height:200px;"/>
	</p>
	<input type="text" name="url" size="50"
	style="display:block; margin:auto"/>
	<div class="container">
  <div class="seek-bar">
  <div id="circle" class="circle">
    <div>
      <em></em>
      <em></em>
    </div>
    <svg xmlns="http://www.w3.org/2000/svg" version="1.1">
      <defs>
        <filter id="svg_goo" filterUnits="objectBoundingBox">
          <feGaussianBlur in="SourceGraphic" stdDeviation="10" result="blur" />
          <feColorMatrix in="blur" mode="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 30 -11" result="svg_goo" />
          <feBlend in="SourceGraphic" in2="svg_goo" />
        </filter>
      </defs>
    </svg>
    <span>0</span>
  </div>
</div>
	<script>
		// 초기값은 50, 읽기전용 활성화
const seekBar = dragElement(document.getElementById("circle"), {
  initVal: 50,
  isReadOnly: true,
});

function dragElement(elmnt, options) {
  let clientX = 0; // elmnt의 clientX값 저장
  let clientX_gab = 0; // 새로운 elmnt의 clientX값과 이전 clientX의 차이
  let leftVal = 0 // elmnt의 left값 저장
  const parentElmnt = elmnt.parentNode;
  
  // 초기 설정
  options = {
    initVal: options.initVal || 0,
    isReadOnly: options.isReadOnly || false,
  };
  init();
  
  // options.initVal을 바탕으로 leftVal값을 구한 후 실제 엘리먼트에 반영(setElmntVal)
  function init() {
    leftVal = Math.round((options.initVal*parentElmnt.clientWidth)/100);
    elmnt.addEventListener("mousedown", dragMouseDown);
    elmnt.addEventListener('touchstart', dragMouseDown);
    setElmntVal(leftVal);
  }
  
  // options를 바꾸기
  function changeOptions(newOptions) {
    options = {
      initVal: newOptions.initVal || 0,
      isReadOnly: newOptions.isReadOnly || false,
    };
    init();
  }
  
  // circle을 눌렀을 때
  function dragMouseDown(e) {
    e = e || window.event;
    e.preventDefault();
    // 읽기전용 상태이면 아무것도 하지 않고 리턴한다.
    if (options.isReadOnly === true) return;
    elmnt.classList.add('s_on');
    if (e.changedTouches) {
      e.clientX = e.changedTouches[0].clientX
    }
    clientX = e.clientX;
    document.addEventListener("mouseup", closeDragElement);
    document.addEventListener('touchend', closeDragElement);
    document.addEventListener("mousemove", elementDrag);
    document.addEventListener('touchmove', elementDrag);
  }

  // 드래그 처리
  function elementDrag(e) {
    e = e || window.event;
    e.preventDefault(); 
    if (e.changedTouches) {
      e.clientX = e.changedTouches[0].clientX
    }
    clientX_gab = e.clientX - clientX;
    clientX = e.clientX;
    
    const newLeftVal = leftVal + clientX_gab;
    
    if ( newLeftVal < 0 || clientX < parentElmnt.offsetLeft ) {
      leftVal = 0; // 최소값
    } else if( parentElmnt.clientWidth < newLeftVal || (parentElmnt.offsetLeft+parentElmnt.clientWidth) < clientX ) {
      leftVal = parentElmnt.clientWidth; // 최대값
    } else {
      leftVal = newLeftVal;
    }
    
    setElmntVal(leftVal);
  }

  // 드래그 끝났을 때 처리
  function closeDragElement() {
    elmnt.classList.remove('s_on');
    document.removeEventListener('mouseup', closeDragElement);
    document.removeEventListener('touchend', closeDragElement);
    document.removeEventListener('mousemove', elementDrag);
    document.removeEventListener('touchmove', elementDrag);
  }
  
  // leftVal를 바탕으로 text랑 transform설정
  function setElmntVal(value){
    elmnt.querySelector('span').innerText = Math.round((value/parentElmnt.clientWidth)*100) || 0;
    elmnt.style.transform = 'translate(calc(-50% + ' + value + 'px),-50%)';
  }
  
  // 외부에서 changeOptions 사용할 수 있도록 return
  return {
    changeOptions: changeOptions,
  }
}

// 3초후 초기값은 0, 읽기전용 비활성화로 변경
setTimeout(function(){
  seekBar.changeOptions({
    initVal: 0,
    isReadOnly: false,
  });
}, 3000);
	</script>
	<input type="button" value="조회하기" style="margin:auto; display:block" />
	
	
</body>
<html>